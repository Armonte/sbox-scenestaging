
#nullable enable

public sealed class DampenTest : Component
{
	[Property]
	public GameObject? Target { get; set; }

	[Property]
	public TextRenderer? Text { get; set; }

	[Property]
	public float UpdateRate { get; set; } = 60f;

	[Property]
	public float Variance { get; set; }

	private Vector3.SpringDamped _spring;

	private float _time;
	private float _updateRate;

	protected override void OnStart()
	{
		_spring = new( 0f, Vector3.Up * 100f, 0f, 2f, 0.125f );
		_updateRate = UpdateRate;
	}

	public void SetPosition( Vector3 position )
	{
		_spring.Current = position;
	}

	public void SetVelocity( Vector3 velocity )
	{
		_spring.Velocity = velocity;
	}

	protected override void OnUpdate()
	{
		_time += Time.Delta;

		var dt = 1f / _updateRate;

		if ( dt <= 0f ) return;

		if ( _time >= dt )
		{
			while ( _time >= dt )
			{
				_time -= dt;
				_spring.Update( dt );
			}

			_updateRate = Math.Max( 1f, UpdateRate + Random.Shared.Float( -Variance, Variance ) );

			if ( Text is { } text )
			{
				text.Text = $"{_updateRate:F1} Hz";
			}
		}

		if ( Target is { } target )
		{
			target.LocalPosition = _spring.Current;
			target.LocalRotation = Rotation.LookAt( target.LocalPosition, Vector3.Forward );

			DebugOverlay.Sphere( new Sphere( target.WorldPosition + _spring.Velocity, 10f ), Color.Red );
			DebugOverlay.Line( target.WorldPosition, target.WorldPosition + _spring.Velocity, Color.Red );
		}
	}
}

/// <summary>
/// Models a unit mass attached to a spring and a damper, with a particular
/// <see cref="Frequency"/> and <see cref="DecayRate"/>.
/// </summary>
/// <param name="Frequency">How many times the spring oscillates per second.</param>
/// <param name="DecayRate">Exponential decay constant λ, higher values decay faster.</param>
internal readonly record struct SpringDamper( float Frequency, float DecayRate )
{
	/// <summary>
	/// Create a model of a damped spring from a <paramref name="frequency"/> and <paramref name="damping"/> per oscillation.
	/// </summary>
	/// <param name="frequency">How many times the spring oscillates per second.</param>
	/// <param name="damping">How much damping to apply each oscillation, as with the legacy <see cref="Vector3.SpringDamp"/>.</param>
	public static SpringDamper FromDamping( float frequency = 2f, float damping = 0.5f ) =>
		new( frequency, damping * frequency * MathF.PI * 2f );

	/// <summary>
	/// Create a critically damped model with a given <paramref name="smoothingTime"/>, for movement that doesn't oscillate but smoothly
	/// settles to the target value.
	/// </summary>
	/// <param name="smoothingTime">Time until the spring has settled.</param>
	public static SpringDamper FromSmoothingTime( float smoothingTime ) =>
		smoothingTime <= 0f
			? FromDamping( 1f, float.PositiveInfinity )
			: FromDamping( 1f / smoothingTime, 1f );

	#region Simulate

	/// <summary>
	/// Simulate the evolution of a unit mass with given <paramref name="position"/> and <paramref name="velocity"/>
	/// being affected by this system, <paramref name="deltaTime"/> seconds into the future.
	/// </summary>
	/// <param name="position">Current displacement of the mass from the spring rest position.</param>
	/// <param name="velocity">Current velocity of the mass.</param>
	/// <param name="deltaTime">How far to simulate into the future.</param>
	public (float Position, float Velocity) Simulate( float position, float velocity, float deltaTime )
	{
		if ( deltaTime <= 0.0f ) return (position, velocity);

		// Natural angular frequency, without damping
		var omega0 = Frequency * MathF.PI * 2f;

		// Damped angular frequency, clamped to be > 0 to avoid division by zero
		var omega = MathF.Sqrt( Math.Max( 0.001f, omega0 * omega0 - DecayRate * DecayRate ) );

		// Simulate spring without decay
		(position, velocity) = SimulateOscillator( position, velocity + DecayRate * position, omega, deltaTime );

		// Apply decay
		(position, velocity) = SimulateDecay( position, velocity, deltaTime );

		return (position, velocity);
	}

	/// <inheritdoc cref="Simulate(float,float,float)"/>
	public (Vector2 Position, Vector2 Velocity) Simulate( Vector2 position, Vector2 velocity, float deltaTime )
	{
		(position.x, velocity.x) = Simulate( position.x, velocity.x, deltaTime );
		(position.y, velocity.y) = Simulate( position.y, velocity.y, deltaTime );

		return (position, velocity);
	}

	/// <inheritdoc cref="Simulate(float,float,float)"/>
	public (Vector3 Position, Vector3 Velocity) Simulate( Vector3 position, Vector3 velocity, float deltaTime )
	{
		(position.x, velocity.x) = Simulate( position.x, velocity.x, deltaTime );
		(position.y, velocity.y) = Simulate( position.y, velocity.y, deltaTime );
		(position.z, velocity.z) = Simulate( position.z, velocity.z, deltaTime );

		return (position, velocity);
	}

	#endregion

	#region Private

	private (float MaxPosition, float MaxVelocity, float Phase) FindOscillationParameters( float position, float velocity, float omega )
	{
		// Total energy (kinetic + potential) x 2, assuming unit mass
		var energy2 = velocity * velocity + omega * omega * position * position;

		if ( energy2 <= 0.001f ) return (0f, 0f, 0f);

		// Find maximum velocity by turning all energy into kinetic
		var vMax = MathF.Sqrt( energy2 );

		// Find maximum amplitude by turning all energy into potential
		var amplitude = vMax / omega;

		// Where are we in the oscillation
		var phase = MathF.Atan2( -velocity, position * omega );

		return (amplitude, vMax, phase);
	}

	private (float Position, float Velocity) SimulateOscillator( float position, float velocity, float omega, float deltaTime )
	{
		// Work out where we are in the oscillation (the phase), and what its amplitude / max velocity is

		var (xMax, vMax, phase) = FindOscillationParameters( position, velocity, omega );

		if ( xMax <= 0f )
		{
			// Fast path if we're not oscillating

			return (0f, 0f);
		}

		// Project it into the future

		return (MathF.Cos( deltaTime * omega + phase ) * xMax,
			-MathF.Sin( deltaTime * omega + phase ) * vMax);
	}

	private (float Position, float Velocity) SimulateDecay( float position, float velocity, float deltaTime )
	{
		var scale = float.IsPositiveInfinity( DecayRate ) ? 0f : MathF.Exp( -deltaTime * DecayRate );

		// Apply exponential decay
		position *= scale;
		velocity *= scale;

		// Apply gradient of exponential decay
		velocity -= DecayRate * position;

		return (position, velocity);
	}

	#endregion
}

public readonly record struct LegacySpringDamperModel( float Frequency, float Damping )
{
	public (float Position, float Velocity) Simulate( float position, float velocity, float deltaTime )
	{
		if ( deltaTime <= 0.0f ) return (position, velocity);

		// Angular frequency (how fast the spring oscillates)
		var omega = Frequency * MathF.PI * 2.0f;

		// Damping factor to control how much oscillation decays over time
		var dampingFactor = Damping * omega;

		// Compute the velocity using spring physics
		var force = omega * omega * -position - 2.0f * dampingFactor * velocity;
		velocity += force * deltaTime;

		// Update position
		return (position + velocity * deltaTime, velocity);
	}
}

public readonly record struct LegacySmoothDamperModel( float SmoothTime )
{
	public (float Position, float Velocity) Simulate( float position, float velocity, float deltaTime )
	{
		// If smoothing time is zero, directly jump to target (independent of timestep)
		if ( SmoothTime <= 0.0f )
		{
			return (0f, velocity);
		}

		// If timestep is zero, stay at current position
		if ( deltaTime <= 0.0f )
		{
			return (position, velocity);
		}

		// Implicit integration of critically damped spring
		var omega = MathF.PI * 2.0f / SmoothTime;
		velocity = (velocity - (omega * omega) * deltaTime * position) / ((1.0f + omega * deltaTime) * (1.0f + omega * deltaTime));

		return (position + velocity * deltaTime, velocity);
	}
}

public sealed class DampenTestManager : Component
{
	[Property, InputAction]
	public string? KickAction { get; set; }

	[Property, Range( -128f, 128f, 0.125f )]
	public float InitialPosition { get; set; }

	[Property, Range( -1024f, 1024f, 1f )]
	public float InitialVelocity { get; set; }

	[Property, Range( 0.1f, 4f )]
	public float Frequency { get; set; } = 2f;

	[Property, Range( 0f, 1f )]
	public float Damping { get; set; } = 0.5f;

	[Property, Range( 1f, 120f )]
	public float FrameRate { get; set; } = 60f;

	protected override void OnUpdate()
	{
		if ( Input.Pressed( KickAction ) )
		{
			var position = Random.Shared.VectorInSphere( 128f );
			var velocity = Random.Shared.VectorInSphere( 1024f );

			foreach ( var test in Scene.GetAllComponents<DampenTest>() )
			{
				test.SetPosition( position );
				test.SetVelocity( velocity );
			}
		}
	}

	protected override void DrawGizmos()
	{
		var dt = 1f / FrameRate;
		var offset = new Vector3( 512f, 0f, 0f );

		Gizmo.Draw.Color = Color.White;
		Gizmo.Draw.Line( new Vector3( 0f, 0f, 0f ) + offset, new Vector3( 10f * 64f, 0f, 0f ) + offset );

		Draw( SpringDamper.FromDamping( Frequency, Damping ).Simulate, offset, 10f, dt, Color.Green );
		Draw( new LegacySpringDamperModel( Frequency, Damping ).Simulate, offset, 10f, dt, Color.Red );
	}

	private void Draw( Func<float, float, float, (float, float)> simulate, Vector3 offset, float duration, float dt, Color color )
	{
		float x = InitialPosition, v = InitialVelocity;

		Gizmo.Draw.Color = color;

		for ( var t = 0f; t <= duration; t += dt )
		{
			var prev = x;

			(x, v) = simulate( x, v, dt );

			if ( Math.Abs( x ) > 1024f )
			{
				x = 0f;
				v = 0f;
			}

			Gizmo.Draw.Line( new Vector3( t * 64f, prev, 0f ) + offset, new Vector3( (t + dt) * 64f, x, 0f ) + offset );
		}
	}
}
